<template>
  <v-form ref="fileUploadInput" lazy-validation>
    <v-file-input
      label="Select a file to upload"
      filled
      dense
      v-model="fileUpload"
      accept=".pdf"
      class="file-upload-preview"
      :rules="fileUploadRules"
      hint="File must be a PDF. Maximum 30MB."
      persistent-hint
      counter
      clearable
      :counter-string=formattedFileSize
      :error-messages="customErrorMessages"
      @change="fileChange($event)"
      @click:clear="fileClear($event)"
    >
    </v-file-input>
  </v-form>
</template>

<script lang="ts">
import Vue from 'vue'
import { Component, Emit, Prop, Watch } from 'vue-property-decorator'
import { PdfPageSize } from '@bcrs-shared-components/enums/'

@Component({})
export default class FileUploadPreview extends Vue {
  @Prop() readonly inputFile: File
  @Prop({ default: 'File' }) readonly inputFileLabel: string
  @Prop({ default: true }) readonly isRequired: boolean
  @Prop({ default: 0 }) readonly maxSize: number // in KB
  @Prop({ default: null }) readonly pdfPageSize: PdfPageSize
  @Prop({ default: false }) readonly showErrors!: boolean
  @Prop({ default: '' }) readonly customErrorMessage: string

  $refs: {
    fileUploadInput: HTMLFormElement
  }

  private fileUpload: File = null
  private customErrorMessages: string[] = []
  private formattedFileSize = '0 MB'

  private fileUploadRules = [
    (v) => {
      if (this.isRequired) {
        return !!v || this.inputFileLabel + ' is required'
      }
      return true
    },
    (file) => {
      if (this.maxSize) {
        const maxSizeMB = this.maxSize / 1024
        const errorMsg = 'Exceeds maximum ' + maxSizeMB.toString() + ' MB file size'
        return (file?.size <= (this.maxSize * 1024)) || errorMsg
      }
      return true
    }
  ]

  async mounted (): Promise<void> {
    if (this.inputFile?.name) {
      this.fileUpload = this.inputFile
      await this.$nextTick()
      this.isFileValid(this.fileUpload)
    }
  }
  /* Triggered by change event */
  private fileChange (file) {
    this.calculateFileSize(file)
    this.emitFileSelected(file)
  }

  /* Triggered by clear event */
  private fileClear (file) {
    this.calculateFileSize(file)
  }

  // Note: the validation is done this way as opposed to being all defined in the validation rules(fileUploadRules)
  //  above because Vuetify does not support async validation out of the box.  This was needed to work
  //  around this limitation.  vuelidate does support this but this would mean introducing a component that
  //  is using a different validation approach or updating all components to use vuelidate.  Have decided
  //  to do this for the time being.
  private async validateFileInput (file) {
    this.customErrorMessages = []
    let isValid = this.$refs.fileUploadInput.validate()
    // only perform page size validation when other validation has passed
    if (isValid && file) {
      if (typeof file.arrayBuffer === 'undefined') { return true }
      const fileInfo = await this.retrieveFileInfo(file)
      if (fileInfo.isEncrypted) {
        this.customErrorMessages = ['File must be unencrypted']
        return false
      }
      if (fileInfo.isContentLocked) {
        this.customErrorMessages = ['File content cannot be locked']
        return false
      }
      const pageSizeIsValid = await this.validatePageSize(file)
      if (!pageSizeIsValid) {
        // show page size validation error
        const pageSizeErrorMsg = this.pageSizeDict[this.pdfPageSize].validationErrorMsg
        this.customErrorMessages = [pageSizeErrorMsg]
      }
      return isValid && pageSizeIsValid
    }
    return isValid
  }

  private async validatePageSize (file): Promise<boolean|string> {
    if (this.pdfPageSize && typeof file.arrayBuffer !== 'undefined') {
      const isValidPageSize = await this.isPageSize(file, this.pdfPageSize)
      return isValidPageSize
    }
    return true
  }

  private calculateFileSize (e: { size: number }) {
    this.formattedFileSize = this.formatBytes(e?.size, 0)
  }

  /** Creates string for file size in bytes, or KB or MB formatted. */
  private formatBytes (bytes: number, decimals = 2): string {
    if (!bytes || bytes === 0) return '0 MB'

    const sizeScale = 1024
    const digits = decimals < 0 ? 0 : decimals
    const sizes = ['Bytes', 'KB', 'MB']

    const i = Math.floor(Math.log(bytes) / Math.log(sizeScale))

    return parseFloat((bytes / Math.pow(sizeScale, i)).toFixed(digits)) + ' ' + sizes[i]
  }

  @Emit('fileSelected')
  async emitFileSelected (file) {
    await this.isFileValid(file)
    return file
  }

  @Emit('isFileValid')
  async isFileValid (file) {
    const result = await this.validateFileInput(file)
    return result
  }

  @Watch('showErrors')
  private onShowErrorsChanged (): void {
    if (this.showErrors) {
      this.validateFileInput(this.fileUpload)
    }
  }

  @Watch('customErrorMessage')
  private onCustomErrorMessage (val: string): void {
    this.customErrorMessages = val ? [val] : []
  }
}
</script>

<style lang="scss" scoped>
@import '@/assets/styles/theme.scss';
::v-deep {
  .file-upload-preview {
    .v-input__append-outer {
      margin-top: 10px !important
    }
    .v-input__slot {
      background-color: $gray1 !important;
    }
    label {
      font-weight: normal;
    }
    .v-file-input__text {
     color: $app-blue !important;
    }
    .v-input__icon--prepend button {
      color: $app-blue !important;
    }
  }
}
</style>
